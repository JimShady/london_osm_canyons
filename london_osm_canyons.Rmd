---
title: "Determining whether London streets are air quality canyons"
author: "James Smith"
output:
  html_document:
  toc: true
toc_float: false
toc_depth: 4
collapsed: false
date: "`r format(Sys.time(), '%Y-%m%-%d %H%:%M')`"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "docs", output_file ="index.html") })
---

```{r include=F}
library(devtools)
library(sf)
devtools::install_github("ropensci/osmdata")
library(osmdata)
library(raster)
devtools::install_github("tidyverse/ggplot2")
library(ggplot2)
library(rgeos)
library(maptools)
library(rgdal)
devtools::install_github("r-spatial/sf")
library(sf)
library(rgeos)
library(data.table)
library(knitr)
library(mapview)
```


## Import building height data
Downloaded from [Copernicus Urban Atlas](https://land.copernicus.eu/local/urban-atlas/building-height-2012?tab=mapview), unzipped and extracted. Now the London raster is imported.

```{r }

london_raster <- raster('buildings_raster/UK001L2_LONDON_UA2012_DHM/UK001L2_LONdON_UA2012_DHM.tif')
plot(london_raster)
title('Raster file of London Building heights')

plot(london_raster, xlim = c(3615000, 3625000), ylim = c(3200000, 3205000))
title('Raster file of London Building heights (zoomed)')

```

## Import OSM roads for the same area as the raster

### Get the boundary for the data we want to download
```{r }

extent              <- extent(london_raster)
extent              <- as(extent, 'SpatialPolygons')
proj4string(extent) <- crs(london_raster)
latlong             <- CRS("+init=epsg:4326")
extent              <- spTransform(extent, latlong)

min_x   <- extent(extent)[1]
max_x   <- extent(extent)[2]
min_y   <- extent(extent)[3]
max_y   <- extent(extent)[4]
rm(extent)
```

Using the [osmdata package](https://cran.r-project.org/web/packages/osmdata/osmdata.pdf) we can download osmdata for the above bounding box. Roads have the value 'highway' in [OpenStreetMap](https://en.wikipedia.org/wiki/OpenStreetMap). Within that heading, we can also filter using the following tags:

```{r}
available_tags('highway')
```

```{r}
primary           <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='primary') %>% osmdata_sf()
primary           <- primary$osm_lines[,c('osm_id', 'lanes', 'geometry')]
primary$type      <- 'primary'

#secondary         <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='secondary') %>% osmdata_sf()
#secondary         <- secondary$osm_lines[,c('osm_id', 'lanes', 'geometry')]
#secondary$type    <- 'secondary'

#motorway          <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='motorway') %>% osmdata_sf()
#motorway          <- motorway$osm_lines[,c('osm_id', 'lanes', 'geometry')]
#motorway$type     <- 'motorway'

#residential       <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='residential') %>% osmdata_sp()
#residential       <- residential$osm_lines[,c('lanes')]
#residential$type  <- 'residential'
#trunk             <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='trunk') %>% osmdata_sf()
#trunk             <- trunk$osm_lines[,c('osm_id', 'lanes', 'geometry')]
#trunk$type        <- 'trunk'

#tertiary          <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='tertiary') %>% osmdata_sp()
#tertiary          <- tertiary$osm_lines[,c('lanes')]
#tertiary$type     <- 'tertiary'

#roads             <- rbind(primary, secondary, motorway, trunk) # Could add residential and tertiary here
roads             <- rbind(primary) # Could add residential and tertiary here
roads$osm_id      <- as.numeric(as.character(roads$osm_id))

rm(primary, secondary, motorway, trunk)
```

Now that we have a SpatialLinesDataFrame of all the London roads, we delete the ones where the 'lane' attribute is not formed properly or contains an error.

```{r}
roads             <- roads[!grepl(';', roads$lanes),]

```

This leaves the following

```{r}
data.frame( type = data.frame(table(roads$type))$Var1, count = data.frame(table(roads$type))$Freq)

```

Presuming that a lane is 3.15 metres wide, each road width is now calculated and added to the dataset. Where roads do not have numebrs of lanes given, the following are presumed:

| Road type   | Lanes |
|-------------|-------|
| Primary     |   2   |
|-------------|-------|
| Secondary   |   2   |
|-------------|-------|
| Motorway    |   6   |
|-------------|-------|
| Residential |   2   |
|-------------|-------|
| Trunk       |   4   |
|-------------|-------|
| Tertiary    |   2   |


```{r}

roads[roads$type == 'primary'     & is.na(roads$lanes),'lanes'] <- 2
roads[roads$type == 'secondary'   & is.na(roads$lanes),'lanes'] <- 2
roads[roads$type == 'motorway'    & is.na(roads$lanes),'lanes'] <- 6
roads[roads$type == 'residential' & is.na(roads$lanes),'lanes'] <- 2
roads[roads$type == 'trunk'       & is.na(roads$lanes),'lanes'] <- 4
roads[roads$type == 'tertiary'    & is.na(roads$lanes),'lanes'] <- 2

roads$width      <- as.numeric(roads$lanes) * 3.15

```

The map below shows roads currently in the dataset, coloured by type

```{r}
ggplot(roads, aes(colour = type, fill=type)) + 
  geom_sf() +
  ggtitle('Downloaded OSM roads, by road type') +
  theme(axis.text = element_blank(),
        panel.background = element_blank(),
        axis.ticks = element_blank(),
        legend.position = 'bottom')
```

Then with the raster and the roads together (after transforming the roads to the same CRS as the raster)

```{r sanity_check}
roads <- st_transform(roads, crs(london_raster)@projargs)

plot(london_raster, xlim=c(3621000, 3622000), ylim = c(3204000,3205000))
plot(st_geometry(roads), add=T)

```

Now we are going to draw two buffers around the roads, one of 10 metres and one of 15 metres. We then take the difference of these two. This resulting 'ring' (shown in red below) will be used as the area to extract building heights from the 'london_raster' layer. The ID values shown as 'roads_to_remove' as roads that are circular, and not suitable for this process. We also need to turn it into a projected CRS before buffering

```{r, warning=F}
roads_to_ignore         <- c(9393,11079,14595,15578)
roads                   <- roads[-roads_to_ignore,]

roads                   <- st_transform(roads, 27700)

roads$area              <- st_geometry(st_buffer(roads, dist = 15)) / st_geometry(st_buffer(roads, dist = 10))

roads$geometry          <- st_transform(roads$geometry, crs(london_raster)@projargs)
roads$area              <- st_transform(roads$area, crs(london_raster)@projargs)

plot(london_raster, xlim=c(3621100, 36213000), ylim = c(3204000,3205000))
plot(st_geometry(roads$area), add=T, xlim=c(3621100, 3621300), ylim = c(3204000,3205000))
```

Now that we have polygon-rings for each road, we can extract the mean building height covered by this ring. Here's an illustration of a road.

```{r include = F}
test_raster <- extent(st_bbox(roads[4,])$xmin-40, st_bbox(roads[4,])$xmax+40, 
                      st_bbox(roads[4,])$ymin-40, st_bbox(roads[4,])$ymax+40)
test_raster <- crop(london_raster, test_raster)

mapview(test_raster, alpha.regions = 0.4) %>% addFeatures(st_transform(roads[4,]$area,4326))
```

These go into new columns in the 'roads' data. Need to work on this bit. Look at function and lapply

#```{r extracting_heights}
#road_polygons   <- as(roads$area,'Spatial')

#non_zero_means_function <- function(x) {
#  mean <- mean(x[,], na.rm=T)
#}

#roads$mean_height_with_zeros  <- extract(london_raster, road_polygons, weights=TRUE, na.rm = F, fun=mean)[,1] #correct

#roads$cell_count              <- extract(london_raster, road_polygons[1:10,], na.rm = F, fun=length)[,1] #correct

```