---
title: "Determining whether London streets are air quality canyons"
author: "James Smith"
output:
  html_document:
    toc: true
    toc_depth: 4
date: "`r format(Sys.time(), '%Y-%m%-%d %H%:%M')`"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "docs", output_file ="index.html") })
---

### Loading libraries
```{r load libraries, message=F, warning=F}
rm(list=ls(all=TRUE)) 

library(devtools)
suppressMessages(devtools::install_github("r-spatial/sf"))
library(sf)
suppressMessages(devtools::install_github("ropensci/osmdata"))
suppressMessages(library(osmdata))
suppressMessages(library(raster))
suppressMessages(devtools::install_github("tidyverse/ggplot2"))
library(ggplot2)
library(rgeos)
library(maptools)
library(rgdal)
library(rgeos)
library(data.table)
library(knitr)
library(mapview)
library(RCurl)
library(stplanr)
```


###  Import building height data

Building height data is downloaded from [Copernicus Urban Atlas](https://land.copernicus.eu/local/urban-atlas/building-height-2012?tab=mapview), unzipped and extracted. Now the London raster is imported.

```{r get building rasters}

london_raster <- raster('buildings_raster/UK001L2_LONDON_UA2012_DHM/UK001L2_LONDON_UA2012_DHM.tif')
plot(london_raster)
title('Raster file of London Building heights')

plot(london_raster, xlim = c(3615000, 3625000), ylim = c(3200000, 3205000))
title('Raster file of London Building heights (zoomed)')

```

### Import OSM roads data

First we get the extent of the raster
```{r get extent of the raster}

extent              <- extent(london_raster)
extent              <- as(extent, 'SpatialPolygons')
proj4string(extent) <- crs(london_raster)
latlong             <- CRS("+init=epsg:4326")
extent              <- spTransform(extent, latlong)

min_x   <- extent(extent)[1]
max_x   <- extent(extent)[2]
min_y   <- extent(extent)[3]
max_y   <- extent(extent)[4]
rm(extent)
```

Now using the [osmdata package](https://cran.r-project.org/web/packages/osmdata/osmdata.pdf) we can download osmdata for the extent we just defined. Roads have the value 'highway' in [OpenStreetMap](https://en.wikipedia.org/wiki/OpenStreetMap). Within that heading, we can also filter using the following tags:

```{r download data from osm, warning=F}
available_tags('highway')
```

Now we import OSM roads data for the following road types.

```{r import road data}
primary           <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='primary') %>% osmdata_sf()
primary           <- primary$osm_lines[,c('osm_id', 'oneway', 'lanes', 'geometry')]
primary$type      <- 'primary'

secondary         <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='secondary') %>% osmdata_sf()
secondary         <- secondary$osm_lines[,c('osm_id', 'oneway', 'lanes', 'geometry')]
secondary$type    <- 'secondary'

motorway          <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='motorway') %>% osmdata_sf()
motorway          <- motorway$osm_lines[,c('osm_id', 'oneway', 'lanes', 'geometry')]
motorway$type     <- 'motorway'

trunk             <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='trunk') %>% osmdata_sf()
trunk             <- trunk$osm_lines[,c('osm_id', 'oneway', 'lanes', 'geometry')]
trunk$type        <- 'trunk'

tertiary          <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='tertiary') %>% osmdata_sf()
tertiary          <- tertiary$osm_lines[,c('osm_id', 'oneway', 'lanes', 'geometry')]
tertiary$type     <- 'tertiary'
```

Then bind them all into one object

```{r bind_roads}
roads             <- rbind(primary, secondary, motorway, trunk, tertiary) 

roads$osm_id      <- as.numeric(as.character(roads$osm_id))

rm(primary, secondary, motorway, trunk, tertiary, max_x, min_x, max_y, min_y)

```

Now that we have a SpatialLinesDataFrame of all the London roads, we delete the ones where the 'lane' attribute is not formed properly or contains an error.

```{r clean lanes data}
roads$lanes       <- as.character(roads$lanes)
roads             <- roads[!grepl(';', roads$lanes),]
roads$lanes       <- as.numeric(roads$lanes)
```

The number of lanes for each road type is below.

```{r check lanes data}
table(roads$type, roads$lanes)

```

Where this is missing, we fill in the blanks, using the mean values of that road type, rounded.

```{r fill_empty_roads}

roads[roads$type == 'primary'     & is.na(roads$lanes),'lanes'] <- round(mean(roads[roads$type == 'primary'     & !is.na(roads$lanes),]$lanes),0)
roads[roads$type == 'secondary'   & is.na(roads$lanes),'lanes'] <- round(mean(roads[roads$type == 'secondary'   & !is.na(roads$lanes),]$lanes),0)
roads[roads$type == 'motorway'    & is.na(roads$lanes),'lanes'] <- round(mean(roads[roads$type == 'motorway'    & !is.na(roads$lanes),]$lanes),0)
roads[roads$type == 'trunk'       & is.na(roads$lanes),'lanes'] <- round(mean(roads[roads$type == 'trunk'       & !is.na(roads$lanes),]$lanes),0)
roads[roads$type == 'tertiary'    & is.na(roads$lanes),'lanes'] <- round(mean(roads[roads$type == 'tertiary'    & !is.na(roads$lanes),]$lanes),0)
```

Now, presuming that a lane is 3.15 metres wide, each road width is now calculated and added to the dataset. 

```{r road_widths}
roads$width             <- as.numeric(roads$lanes) * 3.15
```

OSM splits some roads into two, like Marylebone Road. This is a problem for calculating height to width ratios. So we are going to try and identify these.

```{r marylebone_issue}
roads$half_of_one <- NA

roads[roads$oneway == 'yes' & !is.na(roads$oneway) & roads$type == 'trunk' & !is.na(roads$type),'half_of_one'] <- as.character('Yes')
```

The road widths by road type are now as below

```{r road_widths_summary}

aggregate(width ~ type, data=roads, FUN=summary)

ggplot(roads, aes(y = width, x = type, group=type, fill=type)) + geom_boxplot() + ggtitle('Road widths by road type')
```

The widest road in the dataset is here
```{r checking roads}
m <- mapview(st_buffer(st_transform(roads[roads$width>25,][1,],27700),100), map.types = 'Esri.WorldImagery', alpha.regions=0.1)
mapshot(m, file = paste0(getwd(), "/map.png"), remove_controls = c("zoomControl", "layersControl", "homeButton","scaleBar"))
```

![](map.png)

Pavement width is also added to the roads, depending on what type of road it is, as follows

```{r add pavement widths}

roads$pavement_width   <- NA

roads[roads$type == 'primary',  'pavement_width'] <- 4
roads[roads$type == 'secondary','pavement_width'] <- 4
roads[roads$type == 'motorway', 'pavement_width'] <- 0
roads[roads$type == 'trunk',    'pavement_width'] <- 4
roads[roads$type == 'tertiary', 'pavement_width'] <- 4

roads$total_width <- roads$width + roads$pavement_width

```

With pavements added the roads width is..

```{r road widths summary with pavements}

aggregate(total_width ~ type, data=roads, FUN=summary)

ggplot(roads, aes(y = total_width, x = type, group=type, fill=type)) + geom_boxplot() + ggtitle('Road widths by road type')
```

The map below shows roads currently in the dataset, coloured by type

```{r show downloaded roads}
ggplot(roads, aes(colour = type, fill=type)) + 
  geom_sf() +
  ggtitle('Downloaded OSM roads, by road type') +
  theme(axis.text = element_blank(),
        panel.background = element_blank(),
        axis.ticks = element_blank(),
        legend.position = 'bottom')
```

Remove a few circular roads that are a problem for buffers

```{r remove problem roads}
roads_to_ignore         <- c(9393,11079,14595,15578)
roads                   <- roads[-roads_to_ignore,]
rm(roads_to_ignore)

```

Make the buffers around the roads

```{r make road buffers}
roads                   <- st_transform(roads, 27700)

roads$area              <- st_geometry(st_buffer(roads, dist = 15)) / st_geometry(st_buffer(roads, dist = 10))
```

For the roads like Marylebone Road, going to double and add 5 metres to the buffers.
```{r special_case}
roads[!is.na(roads$half_of_one),]$area              <- st_geometry(st_buffer(roads[!is.na(roads$half_of_one),], dist = 15*2+5)) /
                                                       st_geometry(st_buffer(roads[!is.na(roads$half_of_one),], dist = 10*2+5))
```

Transform the buffers to the same CRS as the raster we're going to extract from.
```{r buffers_transform}
roads$geometry          <- st_transform(roads$geometry,4326)
roads$area              <- st_transform(roads$area, 4326)

roads$geometry          <- st_transform(roads$geometry, crs(london_raster)@projargs)
roads$area              <- st_transform(roads$area, crs(london_raster)@projargs)

```

Check everything looks ok

```{r sanity_check}
plot(london_raster, xlim=c(3621000, 3622000), ylim = c(3204000,3205000))
plot(st_geometry(roads), xlim=c(3621000, 3622000), add=T)
plot(st_geometry(roads$area), xlim=c(3621000, 3622000), add=T)

```

Interactive map view of one feature

```{r map view of a buffer}
temp_raster <- extent(st_bbox(roads[10,])$xmin-40, st_bbox(roads[10,])$xmax+40, 
                      st_bbox(roads[10,])$ymin-40, st_bbox(roads[10,])$ymax+40)
temp_raster <- crop(london_raster, temp_raster)

mapview(temp_raster, alpha.regions = 0.4, map.types = 'OpenStreetMap.BlackAndWhite') %>% addFeatures(st_transform(roads[10,]$area,4326))

rm(temp_raster)
```

Now extract the data we need from the raster (this takes circa 12 hours)

```{r extracting_heights}
road_polygons       <- as(roads$area,'Spatial')
roads$area          <- NULL 

roads$weighted_mean <- NA
roads$cell_count    <- NA
roads$zero_cells    <- NA

print('about extracting data')

extracted <- extract(london_raster, road_polygons, weights=T, na.rm=F)

print('extracted data, using sapply to put into the roads file')

roads$weighted_mean <- sapply(extracted, FUN = function(x)(sum(x[,1] * x[,2])))
roads$cell_count    <- sapply(extracted, FUN = function(x)(length(x[,1])))
roads$zero_cells    <- sapply(extracted, FUN = function(x)(sum(x[,1]==0)))

print('done')

roads$geometry      <- st_transform(roads$geometry, 4326)

rm(london_raster)

```

Now need to get the bearing of each road from start point to end point

```{r calculate bearing}

roads$bearing             <- line_bearing(roads)

hist(roads$bearing)

```

Add another column for height to width ratio

```{r height and width ratio}
roads$height_width_ratio <- roads$weighted_mean / roads$total_width

ggplot(roads, aes(y = height_width_ratio, group=type, x=type, fill=type)) + geom_boxplot() + ggtitle('Height to width ratio by street type')

```

Clean-up some old variables

```{r cleanup}
rm(end_points, start_points, latlong, ukgrid)

print('saving data')

saveRDS(roads, file = "london_roads_output.rds")

```