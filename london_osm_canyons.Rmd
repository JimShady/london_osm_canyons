---
title: "Determining whether London streets are air quality canyons"
author: "James Smith"
output:
  html_document:
  toc: true
toc_float: false
toc_depth: 4
collapsed: false
date: "`r format(Sys.time(), '%Y-%m%-%d %H%:%M')`"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "docs", output_file ="index.html") })
---

```{r include=F}
library(osmdata)
library(raster)
library(ggplot2)
library(maptools)
library(sf)
library(rgeos)
```


## Import building height data
Downloaded from [Copernicus Urban Atlas](https://land.copernicus.eu/local/urban-atlas/building-height-2012?tab=mapview), unzipped and extracted. Now the London raster is imported.

```{r }

london_raster <- raster('buildings_raster/UK001L2_LONDON_UA2012_DHM/UK001L2_LONdON_UA2012_DHM.tif')
plot(london_raster)
title('Raster file of London Building heights')

plot(london_raster, xlim = c(3615000, 3625000), ylim = c(3200000, 3205000))
title('Raster file of London Building heights (zoomed)')

```

## Import OSM roads for the same area as the raster

### Get the boundary for the data we want to download
```{r }

latlong             <- CRS("+init=epsg:4326")
extent              <- extent(london_raster)
extent              <- as(extent, 'SpatialPolygons')
proj4string(extent) <- crs(london_raster)
extent              <- spTransform(extent, latlong)

min_x   <- extent(extent)[1]
max_x   <- extent(extent)[2]
min_y   <- extent(extent)[3]
max_y   <- extent(extent)[4]
rm(extent)
```

Using the [osmdata package](https://cran.r-project.org/web/packages/osmdata/osmdata.pdf) we can download osmdata for the above bounding box. Roads have the value 'highway' in [OpenStreetMap](https://en.wikipedia.org/wiki/OpenStreetMap). Within that heading, we can also filter using the following tags:

```{r}
available_tags('highway')
```

```{r}
set_overpass_url('https://overpass.kumi.systems/api/interpreter')

primary           <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='primary') %>% osmdata_sp()
primary           <- primary$osm_lines[,c('lanes')]
primary$type      <- 'primary'
secondary         <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='secondary') %>% osmdata_sp()
secondary         <- secondary$osm_lines[,c('lanes')]
secondary$type    <- 'secondary'
motorway          <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='motorway') %>% osmdata_sp()
motorway          <- motorway$osm_lines[,c('lanes')]
motorway$type     <- 'motorway'
residential       <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='residential') %>% osmdata_sp()
residential       <- residential$osm_lines[,c('lanes')]
residential$type  <- 'residential'
trunk             <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='trunk') %>% osmdata_sp()
trunk             <- trunk$osm_lines[,c('lanes')]
trunk$type        <- 'trunk'
tertiary          <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='tertiary') %>% osmdata_sp()
tertiary          <- tertiary$osm_lines[,c('lanes')]
tertiary$type     <- 'tertiary'

roads             <- rbind(primary, secondary, motorway, residential, trunk, tertiary)

rm(primary, secondary, motorway, residential, trunk, tertiary)
```

Now that we have a SpatialLinesDataFrame of all the London roads, we delete the ones where the 'lane' attribute is not formed properly or contains an error.

```{r}
roads             <- roads[!grepl(';', roads$lanes),]
roads             <- roads[!grepl('.', roads$lanes),]

table(roads$type)
```

Presuming that a lane is 3.15 metres wide, each road width is now calculated and added to the dataset. Where roads do not have numebrs of lanes given, the following are presumed:

```{r table, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}

table <- "  
| Road type   | Lanes |
|:-----------:|:-----:|
| Primary     |   2   |
|:-----------:|:-----:|
| Secondary   |   2   |
|:-----------:|:-----:|
| Motorway    |   6   |
|:----------:-|:-----:|
| Residential |   2   |
|:-----------:|:-----:|
| Trunk       |   4   |
|:-----------:|:-----:|
| Tertiary    |   2   |
"
cat(table)

```

```{r}

roads$lanes   <- as.numeric(as.character(roads$lanes))

roads[roads$type == 'primary'     & is.na(roads$lanes),'lanes'] <- 2
roads[roads$type == 'secondary'   & is.na(roads$lanes),'lanes'] <- 2
roads[roads$type == 'motorway'    & is.na(roads$lanes),'lanes'] <- 6
roads[roads$type == 'residential' & is.na(roads$lanes),'lanes'] <- 2
roads[roads$type == 'trunk'       & is.na(roads$lanes),'lanes'] <- 4
roads[roads$type == 'tertiary'    & is.na(roads$lanes),'lanes'] <- 2

roads$width      <- as.numeric(roads$lanes) * 3.15

aggregate(width ~ type, data=roads FUN=count)
table(roads$type, roads$width)

```

The map below shows all non-residential roads (as there are too many residential roads to plot effectively.)

```{r}
ggplot(st_as_sf(roads[roads$type != 'residential',])[1:50,], aes(colour = type, fill=type)) + 
  geom_sf() +
  theme(axis.text = element_blank(),
        panel.background = element_blank(),
        axis.ticks = element_blank(),
        legend.position = 'bottom')
```

Now we draw a buffer of 10 metres around each of the roads, and take the mean of the building heights from the 'london_raster' layer. To do that we first convert the data from WGS84, then to British National Grid, make the polygons, convert these to same CRS as the london_raster, then extract the heights.

```{r}
ukgrid       <- "+init=epsg:27700"
roads        <- spTransform(roads, ukgrid)




Get the roads. Do some sort of filtering to only main roads. Make a buffer around them (dynamically?) and select the average building height from the raster layer. Then get the bearing. Create some rules for road width based on type of the road. Also need to calculate the bearing.