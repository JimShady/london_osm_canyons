---
title: "Determining whether London streets are air quality canyons"
author: "James Smith"
output:
  html_document:
    toc: true
    toc_depth: 4
date: "`r format(Sys.time(), '%Y-%m%-%d %H%:%M')`"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "docs", output_file ="index.html") })
---

```{r load libraries, include=F}
rm(list=ls(all=TRUE)) 

library(devtools)
devtools::install_github("r-spatial/sf")
library(sf)
devtools::install_github("ropensci/osmdata")
library(osmdata)
library(raster)
devtools::install_github("tidyverse/ggplot2")
library(ggplot2)
library(rgeos)
library(maptools)
library(rgdal)
library(rgeos)
library(data.table)
library(knitr)
library(mapview)
library(RCurl)
library(stplanr)
```


## Import building height data
Downloaded from [Copernicus Urban Atlas](https://land.copernicus.eu/local/urban-atlas/building-height-2012?tab=mapview), unzipped and extracted. Now the London raster is imported.

```{r get building rasters}

print('loading raster')
london_raster <- raster('buildings_raster/UK001L2_LONDON_UA2012_DHM/UK001L2_LONDON_UA2012_DHM.tif')
plot(london_raster)
title('Raster file of London Building heights')

plot(london_raster, xlim = c(3615000, 3625000), ylim = c(3200000, 3205000))
title('Raster file of London Building heights (zoomed)')

```

## Import OSM roads for the same area as the raster

### Get the boundary for the data we want to download
```{r get extent of the raster}

extent              <- extent(london_raster)
extent              <- as(extent, 'SpatialPolygons')
proj4string(extent) <- crs(london_raster)
latlong             <- CRS("+init=epsg:4326")
extent              <- spTransform(extent, latlong)

min_x   <- extent(extent)[1]
max_x   <- extent(extent)[2]
min_y   <- extent(extent)[3]
max_y   <- extent(extent)[4]
rm(extent)
```

Using the [osmdata package](https://cran.r-project.org/web/packages/osmdata/osmdata.pdf) we can download osmdata for the above bounding box. Roads have the value 'highway' in [OpenStreetMap](https://en.wikipedia.org/wiki/OpenStreetMap). Within that heading, we can also filter using the following tags:

```{r download data from osm, warning=F}
available_tags('highway')
```

```{r import road data}
print('loading roads')

primary           <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='primary') %>% osmdata_sf()
primary           <- primary$osm_lines[,c('osm_id', 'lanes', 'geometry')]
primary$type      <- 'primary'

print('loaded primary')

secondary         <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='secondary') %>% osmdata_sf()
secondary         <- secondary$osm_lines[,c('osm_id', 'lanes', 'geometry')]
secondary$type    <- 'secondary'

print('loaded secondary')

motorway          <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='motorway') %>% osmdata_sf()
motorway          <- motorway$osm_lines[,c('osm_id', 'lanes', 'geometry')]
motorway$type     <- 'motorway'

print('loaded motorway')

trunk             <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='trunk') %>% osmdata_sf()
trunk             <- trunk$osm_lines[,c('osm_id', 'lanes', 'geometry')]
trunk$type        <- 'trunk'

print('loaded trunk')

tertiary          <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='tertiary') %>% osmdata_sf()
tertiary          <- tertiary$osm_lines[,c('osm_id', 'lanes', 'geometry')]
tertiary$type     <- 'tertiary'

print('loaded tertiary')

print('binding roads')

roads             <- rbind(primary, secondary, motorway, trunk, tertiary) 
roads$osm_id      <- as.numeric(as.character(roads$osm_id))

print('bound roads')

rm(primary, secondary, motorway, trunk, tertiary, max_x, min_x, max_y, min_y)

```

Now that we have a SpatialLinesDataFrame of all the London roads, we delete the ones where the 'lane' attribute is not formed properly or contains an error.

```{r clean lanes data}
roads$lanes       <- as.character(roads$lanes)
roads             <- roads[!grepl(';', roads$lanes),]
roads$lanes       <- as.numeric(roads$lanes)
```

The number of lanes for each road type

```{r check lanes data}
table(roads$type, roads$lanes)

```

Presuming that a lane is 3.15 metres wide, each road width is now calculated and added to the dataset. Where roads do not have numbers of lanes given, the following are presumed:

| Road type   | Lanes |
|-------------|-------|
| Primary     |   2   |
| Secondary   |   2   |
| Motorway    |   6   |
| Residential |   2   |
| Trunk       |   4   |
| Tertiary    |   2   |

```{r road_widths}

roads[roads$type == 'primary'     & is.na(roads$lanes),'lanes'] <- 2
roads[roads$type == 'secondary'   & is.na(roads$lanes),'lanes'] <- 2
roads[roads$type == 'motorway'    & is.na(roads$lanes),'lanes'] <- 6
roads[roads$type == 'trunk'       & is.na(roads$lanes),'lanes'] <- 4
roads[roads$type == 'tertiary'    & is.na(roads$lanes),'lanes'] <- 2

roads$width             <- as.numeric(roads$lanes) * 3.15
```

The road widths by road type are now as below

```{r road_widths_summary}

aggregate(width ~ type, data=roads, FUN=summary)

ggplot(roads, aes(y = width, x = type, group=type, fill=type)) + geom_boxplot() + ggtitle('Road widths by road type')
```

The widest road in the dataset is here
```{r checking roads}
m <- mapview(st_buffer(roads[roads$width>25,][1,],100), map.types = 'Esri.WorldImagery', alpha.regions=0.1)
mapshot(m, file = paste0(getwd(), "/map.png"), remove_controls = c("zoomControl", "layersControl", "homeButton","scaleBar"))
```

![](map.png)

Pavement width is also added to the roads, depending on what type of road it is, as follows

```{r add pavement widths}

roads$pavement_width   <- NA

roads[roads$type == 'primary',  'pavement_width'] <- 4
roads[roads$type == 'secondary','pavement_width'] <- 4
roads[roads$type == 'motorway', 'pavement_width'] <- 0
roads[roads$type == 'trunk',    'pavement_width'] <- 4
roads[roads$type == 'tertiary', 'pavement_width'] <- 4

roads$total_width <- roads$width + roads$pavement_width

```

With pavements added the roads width is..

```{r road widths summary with pavements}

aggregate(total_width ~ type, data=roads, FUN=summary)

ggplot(roads, aes(y = total_width, x = type, group=type, fill=type)) + geom_boxplot() + ggtitle('Road widths by road type')
```

The map below shows roads currently in the dataset, coloured by type

```{r show downloaded roads}
ggplot(roads, aes(colour = type, fill=type)) + 
  geom_sf() +
  ggtitle('Downloaded OSM roads, by road type') +
  theme(axis.text = element_blank(),
        panel.background = element_blank(),
        axis.ticks = element_blank(),
        legend.position = 'bottom')
```

Remove a few circular roads that are a problem for buffers

```{r remove problem roads}
roads_to_ignore         <- c(9393,11079,14595,15578)
roads                   <- roads[-roads_to_ignore,]
rm(roads_to_ignore)

```

Make the buffers around the roads

```{r make road buffers}
roads                   <- st_transform(roads, 27700)

roads$area              <- st_geometry(st_buffer(roads, dist = 15)) / st_geometry(st_buffer(roads, dist = 10))

roads$geometry          <- st_transform(roads$geometry,4326)
roads$area              <- st_transform(roads$area, 4326)

roads$geometry          <- st_transform(roads$geometry, crs(london_raster)@projargs)
roads$area              <- st_transform(roads$area, crs(london_raster)@projargs)

```

Check everything looks ok

```{r sanity_check}
plot(london_raster, xlim=c(3621000, 3622000), ylim = c(3204000,3205000))
plot(st_geometry(roads), xlim=c(3621000, 3622000), add=T)
plot(st_geometry(roads$area), xlim=c(3621000, 3622000), add=T)

```

Interactive map view of one feature

```{r map view of a buffer}
temp_raster <- extent(st_bbox(roads[10,])$xmin-40, st_bbox(roads[10,])$xmax+40, 
                      st_bbox(roads[10,])$ymin-40, st_bbox(roads[10,])$ymax+40)
temp_raster <- crop(london_raster, temp_raster)

mapview(temp_raster, alpha.regions = 0.4, map.types = 'OpenStreetMap.BlackAndWhite') %>% addFeatures(st_transform(roads[10,]$area,4326))

rm(temp_raster)
```

Now extract the data we need from the raster (this takes circa 12 hours)

```{r extracting_heights}
road_polygons       <- as(roads$area,'Spatial')
roads$area          <- NULL 

roads$weighted_mean <- NA
roads$cell_count    <- NA
roads$zero_cells    <- NA

print('about extracting data')

extracted <- extract(london_raster, road_polygons, weights=T, na.rm=F)

print('extracted data, using sapply to put into the roads file')

roads$weighted_mean <- sapply(extracted, FUN = function(x)(sum(x[,1] * x[,2])))
roads$cell_count    <- sapply(extracted, FUN = function(x)(length(x[,1])))
roads$zero_cells    <- sapply(extracted, FUN = function(x)(sum(x[,1]==0)))

print('done')

roads$geometry      <- st_transform(roads$geometry, 4326)

rm(london_raster)

```

Now need to get the bearing of each road from start point to end point

```{r calculate bearing}
ukgrid = "+init=epsg:27700"

start_points              <- as(line_to_points(roads), 'Spatial')
proj4string(start_points) <- latlong
start_points              <- spTransform(start_points, ukgrid)
start_points              <- data.frame(start_points)
start_points              <- aggregate(.~id, start_points, FUN=head, 1)
start_points$optional     <- NULL
names(start_points)       <- c('id', 'start_x', 'start_y')
coordinates(start_points) <- ~start_x+start_y
proj4string(start_points) <- ukgrid
start_points              <- spTransform(start_points, latlong)

end_points                <- as(line_to_points(roads), 'Spatial')
proj4string(end_points)   <- latlong
end_points                <- spTransform(end_points, ukgrid)
end_points                <- data.frame(end_points)
end_points                <- aggregate(.~id, end_points, FUN=tail, 1)
end_points$optional       <- NULL
names(end_points)         <- c('id', 'end_x', 'end_y')
coordinates(end_points)   <- ~end_x+end_y
proj4string(end_points)   <- ukgrid
end_points                <- spTransform(end_points, latlong)

roads$bearing             <- bearing(start_points, end_points)

hist(roads$bearing)

```

Add another column for height to width ratio

```{r height and width ratio}
roads$height_width_ratio <- roads$weighted_mean / roads$total_width

ggplot(roads, aes(y = height_width_ratio, group=type, x=type, fill=type)) + geom_boxplot() + ggtitle('Height to width ratio by street type')

```

Clean-up some old variables

```{r cleanup}
rm(end_points, start_points, latlong, ukgrid)

print('saving data')

saveRDS(roads, file = "london_roads_output.rds")

```