---
title: "Determining whether London streets are air quality canyons"
author: "James Smith"
output:
  html_document:
  toc: true
toc_float: false
toc_depth: 4
collapsed: false
date: "`r format(Sys.time(), '%Y-%m%-%d %H%:%M')`"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "docs", output_file ="index.html") })
---

```{r include=F}
library(osmdata)
library(raster)
library(ggplot2)
```


## Import building height data
Downloaded from [Copernicus Urban Atlas](https://land.copernicus.eu/local/urban-atlas/building-height-2012?tab=mapview), unzipped and extracted. Now the London raster is imported.

```{r }

london_raster <- raster('buildings_raster/UK001L2_LONDON_UA2012_DHM/UK001L2_LONdON_UA2012_DHM.tif')
plot(london_raster)
title('Raster file of London Building heights')

plot(london_raster, xlim = c(3615000, 3625000), ylim = c(3200000, 3205000))
title('Raster file of London Building heights (zoomed)')

```

## Import OSM roads for the same area as the raster

### Get the boundary for the data we want to download
```{r }

latlong             <- CRS("+init=epsg:4326")
extent              <- extent(london_raster)
extent              <- as(extent, 'SpatialPolygons')
proj4string(extent) <- crs(london_raster)
extent              <- spTransform(extent, latlong)

min_x   <- extent(extent)[1]
max_x   <- extent(extent)[2]
min_y   <- extent(extent)[3]
max_y   <- extent(extent)[4]
rm(extent)
```

Using the [osmdata package](https://cran.r-project.org/web/packages/osmdata/osmdata.pdf) we can download osmdata for the above bounding box. Roads have the value 'highway' in [OpenStreetMap](https://en.wikipedia.org/wiki/OpenStreetMap). Within that heading, we can also filter using the following tags:

```{r}
available_tags('highway')
```

```{r}
primary       <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='primary') %>% osmdata_sf()
primary       <- primary$osm_lines[,c('osm_id', 'geometry', 'lanes')]
secondary     <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='secondary') %>% osmdata_sf()
secondary     <- secondary$osm_lines[,c('osm_id', 'geometry', 'lanes')]
motorway      <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='motorway') %>% osmdata_sf()
motorway      <- motorway$osm_lines[,c('osm_id', 'geometry', 'lanes')]
residential   <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='residential') %>% osmdata_sf()
residential   <- residential$osm_lines[,c('osm_id', 'geometry', 'lanes')]
trunk         <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='trunk') %>% osmdata_sf()
trunk         <- trunk$osm_lines[,c('osm_id', 'geometry', 'lanes')]
tertiary      <- opq(bbox = c(min_x, min_y, max_x, max_y)) %>% add_osm_feature(key = 'highway', value='tertiary') %>% osmdata_sf()
tertiary      <- tertiary$osm_lines[,c('osm_id', 'geometry', 'lanes')]
roads         <- c(primary, secondary, motorway, residential, trunk, tertiary)
rm(primary, secondary, motorway, residential, trunk, tertiary)

```

Get the roads. Do some sort of filtering to only main roads. Make a buffer around them (dynamically?) and select the average building height from the raster layer. Then get the bearing. Create some rules for road width based on type of the road. Also need to calculate the bearing.